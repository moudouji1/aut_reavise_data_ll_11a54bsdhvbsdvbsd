{
  "title": "üü† S√©ance 1 : Bases de JavaScript moderne, Syntaxe ES6, manipulation du DOM",
  "questions": [
    {
      "question": "Quel est le r√¥le de la fonction `next()` dans un middleware Express ?",
      "options": [
        "Envoyer la r√©ponse finale au client.",
        "Passer le contr√¥le √† la fonction middleware suivante dans la pile.",
        "Lire les donn√©es de la requ√™te entrante.",
        "Terminer l'ex√©cution de l'application."
      ],
      "answer": "Passer le contr√¥le √† la fonction middleware suivante dans la pile.",
      "explanation": "La fonction `next()` doit √™tre appel√©e pour passer le contr√¥le au middleware suivant. Si elle n'est pas appel√©e, la requ√™te restera bloqu√©e."
    },
    {
      "question": "Qu'est-ce que le 'Callback Hell' en JavaScript ?",
      "options": [
        "Une situation o√π trop de callbacks s'ex√©cutent en m√™me temps, provoquant un crash.",
        "Une structure de code avec de multiples niveaux de callbacks imbriqu√©s, rendant le code difficile √† lire et √† maintenir.",
        "Une erreur qui se produit lorsqu'une fonction de rappel n'est pas d√©finie.",
        "Une vuln√©rabilit√© de s√©curit√© li√©e aux fonctions de rappel."
      ],
      "answer": "Une structure de code avec de multiples niveaux de callbacks imbriqu√©s, rendant le code difficile √† lire et √† maintenir.",
      "explanation": "Le 'Callback Hell' (ou 'Pyramid of Doom') fait r√©f√©rence √† la structure en pyramide qui appara√Æt lorsque plusieurs op√©rations asynchrones sont encha√Æn√©es via des callbacks imbriqu√©s, ce qui nuit √† la lisibilit√© du code."
    },
    {
      "question": "Dans le contexte des Promesses (Promises) en JavaScript, quel est l'objectif principal de la m√©thode `.then()` ?",
      "options": [
        "D√©finir le code qui s'ex√©cute lors de la cr√©ation d'une promesse.",
        "Rejeter imm√©diatement une promesse.",
        "Planifier l'ex√©cution d'une fonction lorsque la promesse est r√©solue avec succ√®s.",
        "Mettre en pause l'ex√©cution du script entier jusqu'√† ce que la promesse soit r√©solue."
      ],
      "answer": "Planifier l'ex√©cution d'une fonction lorsque la promesse est r√©solue avec succ√®s.",
      "explanation": "La m√©thode `.then()` est utilis√©e pour g√©rer la r√©solution r√©ussie d'une promesse. Elle prend en argument une fonction qui sera ex√©cut√©e avec la valeur de r√©solution de la promesse."
    },
    {
      "question": "Comment s√©lectionneriez-vous un √©l√©ment HTML avec l'identifiant unique `main-content` en utilisant un s√©lecteur CSS ?",
      "options": [
        ".main-content",
        "#main-content",
        "*main-content",
        "element(main-content)"
      ],
      "answer": "#main-content",
      "explanation": "En CSS, le symbole `#` est utilis√© pour s√©lectionner un √©l√©ment par son attribut `id`. Le symbole `.` est utilis√© pour s√©lectionner les √©l√©ments par leur `class`."
    },
    {
      "question": "Quelle m√©thode JavaScript est principalement utilis√©e pour manipuler le DOM en obtenant un √©l√©ment HTML via son attribut `id` ?",
      "options": [
        "document.getElementsByClassName(\"elementId\")",
        "document.querySelector(\"#elementId\")",
        "document.getElementById(\"elementId\")",
        "document.getElementsByTagName(\"elementId\")"
      ],
      "answer": "document.getElementById(\"elementId\")",
      "explanation": "`document.getElementById(\"elementId\")` est la m√©thode la plus directe et classique pour s√©lectionner un √©l√©ment unique en se basant sur son ID."
    },
    {
      "question": "Quel est le but de la fonction `$(document).ready()` en jQuery ?",
      "options": [
        "Charger toutes les images et ressources externes de la page.",
        "D√©marrer l'ex√©cution de la biblioth√®que jQuery elle-m√™me.",
        "S'assurer que le code qu'elle contient ne s'ex√©cute qu'une fois que le DOM du document est enti√®rement charg√©.",
        "V√©rifier les erreurs de syntaxe dans le code jQuery."
      ],
      "answer": "S'assurer que le code qu'elle contient ne s'ex√©cute qu'une fois que le DOM du document est enti√®rement charg√©.",
      "explanation": "`$(document).ready()` est un √©v√©nement jQuery crucial qui attend que le DOM soit compl√®tement charg√© avant d'ex√©cuter le code, √©vitant ainsi les erreurs li√©es √† la manipulation d'√©l√©ments non encore cr√©√©s."
    },
    {
      "question": "Quelle est la principale diff√©rence entre la d√©claration d'une variable avec `let` et `const` en ES6 ?",
      "options": [
        "`let` est pour les nombres et `const` pour les cha√Ænes de caract√®res.",
        "Une variable d√©clar√©e avec `let` peut √™tre r√©affect√©e, tandis qu'une variable `const` ne le peut pas.",
        "`let` a une port√©e globale, tandis que `const` a une port√©e locale.",
        "Il n'y a pas de diff√©rence fonctionnelle, elles sont interchangeables."
      ],
      "answer": "Une variable d√©clar√©e avec `let` peut √™tre r√©affect√©e, tandis qu'une variable `const` ne le peut pas.",
      "explanation": "`const` d√©clare une constante, ce qui signifie que sa r√©f√©rence ne peut pas √™tre r√©affect√©e apr√®s sa d√©claration initiale. `let` d√©clare une variable dont la valeur peut √™tre modifi√©e. Toutes deux ont une port√©e de bloc (block scope)."
    },
    {
      "question": "Quelle est la fonctionnalit√© principale que TypeScript ajoute √† JavaScript ?",
      "options": [
        "Une nouvelle fa√ßon de manipuler le DOM.",
        "Le typage statique optionnel.",
        "Un serveur web int√©gr√©.",
        "La capacit√© d'ex√©cuter du JavaScript c√¥t√© serveur."
      ],
      "answer": "Le typage statique optionnel.",
      "explanation": "TypeScript est un surensemble de JavaScript, et sa contribution majeure est l'ajout de types statiques optionnels, ce qui aide √† d√©tecter les erreurs pendant le d√©veloppement et √† am√©liorer la maintenabilit√© du code."
    }
  ]
}